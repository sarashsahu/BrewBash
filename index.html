<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brew Bash Mobile</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        /* Import the 'Press Start 2P' font for a video game feel */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start 2P&display=swap');
        
        body {
            /* Apply the video game font to the entire body */
            font-family: 'Press Start 2P', cursive;
            background-color: #1a202c;
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
            padding: 10px;
            box-sizing: border-box;
        }
        .game-wrapper {
            display: flex;
            flex-direction: column; /* Default to column for small screens */
            align-items: center;
            gap: 20px;
            background-color: #2d3748;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            max-width: 95vw;
            width: fit-content;
            margin: auto;
        }
        @media (min-width: 768px) {
            .game-wrapper {
                flex-direction: row; /* Row for larger screens */
                max-width: none;
                width: auto;
            }
        }

        .main-game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px; /* Space between canvas and buttons */
            width: 350px; /* Match canvas width */
            max-width: 100%;
        }

        canvas {
            background-color: #000;
            display: block;
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            width: 350px; /* Fixed width for consistency */
            height: 600px;
            max-width: 100%;
            height: auto; /* Allow height to adjust based on aspect ratio */
            object-fit: contain;
            touch-action: pan-y; /* Allow vertical scrolling on canvas if it overflows, but not horizontal panning/zooming */
        }

        .control-panel {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            background-color: #4a5568;
            padding: 20px;
            border-radius: 10px;
            width: 350px; /* Set to the same width as the canvas */
            max-width: 100%; /* Ensure it's responsive */
            min-width: 200px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            flex-grow: 1;
        }
        /* No specific @media for control-panel width, it will adapt */

        .game-info h2 {
            font-size: 1.1rem; /* Adjusted for pixel font readability */
            font-weight: normal; /* Pixel fonts often don't have bold variants */
            margin-bottom: 10px;
            color: #a0aec0;
            text-align: center;
        }
        .stats-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.85rem; /* Adjusted for pixel font readability */
        }
        .stats-item span:first-child {
            font-weight: normal; /* Pixel fonts often don't have bold variants */
            color: #cbd5e0;
        }
        .progress-bar {
            background-color: #6a748c;
            border-radius: 5px;
            height: 10px;
            width: 100%;
            overflow: hidden;
            margin-top: 3px;
        }
        .progress-fill {
            height: 100%;
            width: 0%;
            background-color: lightgreen;
            border-radius: 5px;
            transition: width 0.2s ease-in-out, background-color 0.2s ease-in-out;
        }
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            /* margin-top: 20px; Removed as it's now part of main-game-area gap */
            width: 100%; /* Ensure buttons fill the container width */
        }
        .game-button {
            background-color: #4299e1;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.9rem; /* Adjusted for pixel font readability */
            font-weight: normal; /* Pixel fonts often don't have bold variants */
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            border: none;
            width: 100%;
            touch-action: manipulation; /* Prevent zooming */
        }
        .game-button:hover:not(:disabled) {
            background-color: #3182ce;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
        }
        .game-button:disabled {
            background-color: #a0aec0;
            cursor: not-allowed;
            opacity: 0.7;
        }
        .mobile-controls {
            display: flex;
            justify-content: space-around;
            width: 100%;
            /* margin-top: 20px;
            margin-bottom: 20px; Removed as it's now part of main-game-area gap */
            gap: 10px;
        }
        .mobile-button {
            background-color: #ed8936;
            color: white;
            padding: 18px 35px;
            border-radius: 50%;
            font-size: 1.5rem; /* Adjusted for pixel font readability */
            font-weight: normal; /* Pixel fonts often don't have bold variants */
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            border: none;
            min-width: 70px;
            min-height: 70px;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: manipulation; /* Prevent zooming */
        }
        .mobile-button:hover:not(:disabled) {
            background-color: #dd6b20;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
        }
        .mobile-button:disabled {
            background-color: #a0aec0;
            cursor: not-allowed;
            opacity: 0.7;
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .overlay-content {
            background-color: #2d3748;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 90%;
            width: 400px;
        }
        .overlay-content h2 {
            font-size: 1.8rem; /* Adjusted for pixel font readability */
            color: #e2e8f0;
            margin-bottom: 15px;
        }
        .overlay-content p {
            font-size: 1rem; /* Adjusted for pixel font readability */
            color: #cbd5e0;
            margin-bottom: 20px;
        }
        .overlay-content button {
            background-color: #48bb78;
            color: white;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1rem; /* Adjusted for pixel font readability */
            font-weight: normal; /* Pixel fonts often don't have bold variants */
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            border: none;
            touch-action: manipulation; /* Prevent zooming */
        }
        .overlay-content button:hover {
            background-color: #38a169;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <div class="main-game-area">
            <canvas id="roadCanvas" width="350" height="600"></canvas>
            <div class="mobile-controls">
                <button id="moveLeftBtn" class="mobile-button">◀</button>
                <button id="moveRightBtn" class="mobile-button">▶</button>
            </div>
        </div>
        <div class="control-panel">
            <div class="game-info">
                <h2>Brew Bash Mobile</h2>
                <div class="stats-item">
                    <span>Score:</span>
                    <span id="hudScore">0</span>
                </div>
                <div class="stats-item">
                    <span>Speed:</span>
                    <span id="hudSpeed">0 km/h</span>
                </div>
                <div class="progress-bar">
                    <div id="speedBarFill" class="progress-fill" style="width: 0%; background-color: lightgreen;"></div>
                </div>
                <div class="stats-item mt-4">
                    <span>Health:</span>
                    <span id="hudHealthValue">100%</span>
                </div>
                <div class="progress-bar">
                    <div id="healthBarFill" class="progress-fill" style="width: 100%; background-color: limegreen;"></div>
                </div>
                <br>
            </div>
                <div class="button-group">
                <button id="playBtn" class="game-button">Play</button>
                <button id="pauseBtn" class="game-button" disabled>Pause</button>
                <button id="restartBtn" class="game-button">Restart</button>
                <span style="font-weight: normal; font-size: 0.8rem; color: #a0aec0; text-align: center; margin-top: 10px;">Developed By ⬇️</span>
                <a href="https://www.instagram.com/sarashsahu" target="_blank" class="game-button" style="text-align: center;">@sarashsahu</a>
            </div>
            </div>
        </div>
    </div>

    <div id="nameInputOverlay" class="overlay">
        <div class="overlay-content">
            <h2 style="color: red;">Game Over!</h2>
            <p>Your Score: <span id="finalScore">0</span></p>
            <p>Don't Drink and Drive!</p>
            <button id="closeOverlayBtn">OK</button>
        </div>
    </div>

    <audio id="backgroundMusic" loop>
        <source src="background_music.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <script>
        const canvas = document.getElementById('roadCanvas');
        const ctx = canvas.getContext('2d');

        const roadWidth = 300;
        const centerX = canvas.width / 2;
        const carWidth = 50;
        const carHeight = 110;
        const carY = canvas.height - carHeight - 140;
        const carBaseX = centerX - roadWidth / 2 + 20;
        const maxOffset = roadWidth - carWidth - 40;

        const baseCarMoveSpeed = 400;
        const baseObstacleSpeed = 200;

        let carOffsetX = 0;
        let dashOffset = 0;
        let score = 0;
        let health = 100;
        let gameOver = false;
        let lampposts = [];
        let gameSpeedMultiplier = 1;
        let lastLamppostY = -200;
        const keys = { left: false, right: false };
        let healthDrop = null;
        let animationId = null;
        let paused = true;
        let countdownActive = false;
        let countdownStartTime = 0; // Initialize to 0

        let healthDrop25PercentGiven = false;

        let carBlinkActive = false;
        let carBlinkStartTime = 0;
        const CAR_BLINK_DURATION = 1500;
        const CAR_BLINK_INTERVAL = 100;

        let blindEffectActive = false;
        let blindEffectStartTime = 0;
        const BLIND_EFFECT_DURATION = 2000;

        const nameOverlay = document.getElementById('nameInputOverlay');
        const finalScoreSpan = document.getElementById('finalScore');
        const closeOverlayBtn = document.getElementById('closeOverlayBtn');
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const restartBtn = document.getElementById('restartBtn');

        const hudScore = document.getElementById('hudScore');
        const hudSpeed = document.getElementById('hudSpeed');
        const speedBarFill = document.getElementById('speedBarFill');
        const hudHealthValue = document.getElementById('hudHealthValue');
        const healthBarFill = document.getElementById('healthBarFill');

        const moveLeftBtn = document.getElementById('moveLeftBtn');
        const moveRightBtn = document.getElementById('moveRightBtn');

        let carImageLoaded = false;
        let beerImageLoaded = false;
        let heartImageLoaded = false;

        const carImage = new Image();
        carImage.src = 'car.png'; // Replace with your car image URL
        carImage.onload = () => carImageLoaded = true;
        carImage.onerror = () => {
            console.error("Failed to load car image, using fallback.");
            carImageLoaded = false;
        };

        const beerImage = new Image();
        beerImage.src = 'beer.png'; // Replace with your beer image URL
        beerImage.onload = () => beerImageLoaded = true;
        beerImage.onerror = () => {
            console.error("Failed to load beer image, using fallback.");
            beerImageLoaded = false;
        };

        const heartImage = new Image();
        heartImage.src = 'heart.png'; // Replace with your heart image URL
        heartImage.onload = () => heartImageLoaded = true;
        heartImage.onerror = () => {
            console.error("Failed to load heart image, using fallback.");
            heartImageLoaded = false;
        };

        const backgroundMusic = document.getElementById('backgroundMusic');
        const crashSound = new Audio('crash.mp3'); // Replace with your crash sound URL
        crashSound.volume = 0.5;
        crashSound.onerror = () => console.error("Failed to load crash sound.");

        const gameOverSound = new Audio('gameover.mp3'); // Replace with your game over sound URL
        gameOverSound.volume = 0.5;
        gameOverSound.onerror = () => console.error("Failed to load game over sound.");

        const collectSound = new Audio('health.mp3');
        collectSound.volume = 0.5;
        collectSound.onerror = () => console.error("Failed to load collect sound.");

        const defaultBackgroundMusicVolume = 0.3; // Adjust as needed
        const duckedBackgroundMusicVolume = 0.1; // Adjust as needed for ducking

        backgroundMusic.volume = defaultBackgroundMusicVolume;

        // Function to duck/unduck background music
        function duckBackgroundMusic() {
            backgroundMusic.volume = duckedBackgroundMusicVolume;
        }

        function unduckBackgroundMusic() {
            backgroundMusic.volume = defaultBackgroundMusicVolume;
        }

        // Event listeners for ducking
        crashSound.addEventListener('play', duckBackgroundMusic);
        crashSound.addEventListener('ended', unduckBackgroundMusic);
        gameOverSound.addEventListener('play', duckBackgroundMusic);
        gameOverSound.addEventListener('ended', unduckBackgroundMusic);
        collectSound.addEventListener('play', duckBackgroundMusic);
        collectSound.addEventListener('ended', unduckBackgroundMusic);

        // Event Listeners for mobile/touch input on canvas
        canvas.addEventListener('touchstart', handleCanvasTouch);
        canvas.addEventListener('mousedown', handleCanvasClick); // For mouse clicks on desktop/laptops

        playBtn.addEventListener('click', () => {
            if (gameOver || countdownActive) return;
            if (paused) {
                countdownActive = true;
                countdownStartTime = 0; // Reset to 0 so countdownAnimation initializes it with requestAnimationFrame's timestamp
                updateButtonStates();
                requestAnimationFrame(countdownAnimation);
            }
        });

        pauseBtn.addEventListener('click', () => {
            if (!gameOver && !paused) {
                paused = true;
                backgroundMusic.pause(); // Pause background music
                if (animationId) cancelAnimationFrame(animationId);
                updateButtonStates();
            }
        });

        restartBtn.addEventListener('click', () => {
            resetGame();
            paused = true; // Start in paused state with countdown on play
            backgroundMusic.pause(); // Ensure music is paused before restart
            backgroundMusic.currentTime = 0; // Reset music to start
            if (animationId) cancelAnimationFrame(animationId);
            updateButtonStates();
            // No immediate animate() call, relies on Play button
        });

        document.addEventListener('keydown', e => {
            const typing = ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName);
            if (!typing) {
                if (e.code === 'KeyA' || e.code === 'ArrowLeft') keys.left = true;
                if (e.code === 'KeyD' || e.code === 'ArrowRight') keys.right = true;
            }
        });

        document.addEventListener('keyup', e => {
            if (e.code === 'KeyA' || e.code === 'ArrowLeft') keys.left = false;
            if (e.code === 'KeyD' || e.code === 'ArrowRight') keys.right = false;
        });

        closeOverlayBtn.addEventListener('click', () => {
            nameOverlay.style.display = 'none';
            resetGame();
            paused = true;
            backgroundMusic.pause(); // Pause background music when game over overlay is closed
            backgroundMusic.currentTime = 0; // Reset music
            updateButtonStates();
            if (animationId) cancelAnimationFrame(animationId);
        });

        // Keep direct button controls if needed, or remove if canvas controls are primary
        moveLeftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); if (!gameOver && !paused) keys.left = true; });
        moveLeftBtn.addEventListener('touchend', (e) => { e.preventDefault(); keys.left = false; });
        moveLeftBtn.addEventListener('mousedown', () => { if (!gameOver && !paused) keys.left = true; });
        moveLeftBtn.addEventListener('mouseup', () => { keys.left = false; });
        moveLeftBtn.addEventListener('mouseleave', () => { keys.left = false; });

        moveRightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); if (!gameOver && !paused) keys.right = true; });
        moveRightBtn.addEventListener('touchend', (e) => { e.preventDefault(); keys.right = false; });
        moveRightBtn.addEventListener('mousedown', () => { if (!gameOver && !paused) keys.right = true; });
        moveRightBtn.addEventListener('mouseup', () => { keys.right = false; });
        moveRightBtn.addEventListener('mouseleave', () => { keys.left = false; });

        function showGameOverOverlay() {
            finalScoreSpan.textContent = score;
            nameOverlay.style.display = 'flex';
            backgroundMusic.pause(); // Pause background music on game over
            updateButtonStates();
        }

        function updateButtonStates() {
            playBtn.disabled = !paused || gameOver || countdownActive;
            pauseBtn.disabled = paused || gameOver || countdownActive;
            restartBtn.disabled = false;
            // Mobile movement buttons are now controlled by canvas taps primarily, but these can still be used.
            moveLeftBtn.disabled = paused || gameOver || countdownActive; 
            moveRightBtn.disabled = paused || gameOver || countdownActive;
        }

        function spawnLamppost() {
            const spacing = Math.random() * 150 + 200;
            lastLamppostY -= spacing;
            const x = carBaseX + Math.random() * (roadWidth - 40);
            lampposts.push({ x, y: lastLamppostY, checked: false });
        }

        function rectCircleColliding(cx, cy, r, rx, ry, rw, rh) {
            const dx = Math.abs(cx - rx - rw / 2);
            const dy = Math.abs(cy - ry - rh / 2);
            if (dx > rw / 2 + r || dy > rh / 2 + r) return false;
            if (dx <= rw / 2 || dy <= rh / 2) return true;
            const dx2 = dx - rw / 2;
            const dy2 = dy - rh / 2;
            return dx2 * dx2 + dy2 * dy2 <= r * r;
        }

        function updateLampposts(deltaTime) {
            if (!gameOver && (lampposts.length === 0 || canvas.height - lastLamppostY > 200)) {
                spawnLamppost();
            }

            const carX = carBaseX + carOffsetX;
            for (let i = lampposts.length - 1; i >= 0; i--) {
                const l = lampposts[i];
                l.y += (gameSpeedMultiplier * baseObstacleSpeed / 1000) * deltaTime;

                if (beerImageLoaded) {
                    const imgWidth = 20;
                    const imgHeight = 30;
                    ctx.drawImage(beerImage, l.x - imgWidth / 2, l.y - imgHeight / 2, imgWidth, imgHeight);
                } else {
                    ctx.beginPath();
                    ctx.arc(l.x, l.y, 6, 0, Math.PI * 2);
                    ctx.fillStyle = '#FFD700';
                    ctx.fill();
                }

                if (!l.checked && !carBlinkActive && rectCircleColliding(l.x, l.y, 10, carX, carY, carWidth, carHeight)) {
                    l.checked = true;
                    crashSound.currentTime = 0;
                    crashSound.play();
                    health -= 25;

                    carBlinkActive = true;
                    carBlinkStartTime = Date.now();

                    updateHUDDisplay();

                    if (health <= 0) {
                        health = 0;
                        gameOver = true;
                        paused = true;
                        crashSound.pause();
                        crashSound.currentTime = 0;
                        gameOverSound.currentTime = 0;
                        gameOverSound.play();
                        if (animationId) cancelAnimationFrame(animationId);
                        showGameOverOverlay();
                    }
                }

                if (health === 25 && !healthDrop25PercentGiven && (!healthDrop || !healthDrop.active)) {
                    const dropX = carBaseX + Math.random() * maxOffset;
                    healthDrop = { x: dropX, y: -50, active: true };
                    healthDrop25PercentGiven = true;
                }

                if (l.y > canvas.height + 10) {
                    lampposts.splice(i, 1);
                    if (!l.checked && !gameOver) {
                        score += 50;
                        gameSpeedMultiplier = getSpeedForScore(score);
                        updateHUDDisplay();
                    }
                }
            }
        }

        function updateHealthDrop(deltaTime) {
            if (!healthDrop || !healthDrop.active) return;

            healthDrop.y += (gameSpeedMultiplier * baseObstacleSpeed / 1000) * deltaTime;

            if (heartImageLoaded) {
                const imgWidth = 20;
                const imgHeight = 20;
                ctx.drawImage(heartImage, healthDrop.x - imgWidth / 2, healthDrop.y - imgHeight / 2, imgWidth, imgHeight);
            } else {
                ctx.font = '24px serif';
                ctx.textAlign = 'center';
                ctx.fillText('💖', healthDrop.x, healthDrop.y);
            }

            const carX = carBaseX + carOffsetX;
            if (
                healthDrop.active &&
                healthDrop.y >= carY &&
                healthDrop.y <= carY + carHeight &&
                healthDrop.x >= carX &&
                healthDrop.x <= carX + carWidth
            ) {
                const dropAmount = 25;
                health = Math.min(health + dropAmount, 100);
                healthDrop.active = false;
                collectSound.currentTime = 0;
                collectSound.play();
                updateHUDDisplay();
            }

            if (healthDrop.y > canvas.height) {
                healthDrop.active = false;
            }
        }

        function getSpeedForScore(score) {
            if (score < 500) return 1.0;
            if (score < 1000) return 1.2;
            if (score < 2000) return 1.4;
            if (score < 3000) return 1.6;
            if (score < 4000) return 1.8;
            if (score < 5000) return 2.0;
            if (score < 6000) return 2.2;
            if (score < 7000) return 2.4;
            if (score < 8000) return 2.6;
            if (score < 10000) return 2.8;
            if (score < 12000) return 3.0;
            if (score < 14000) return 3.2;
            if (score < 16000) return 3.4;
            if (score < 18000) return 3.6;
            if (score < 20000) return 3.8;

            return 4.0;
        }

        function drawRoad() {
            ctx.fillStyle = '#222';
            ctx.fillRect(centerX - roadWidth / 2, 0, roadWidth, canvas.height);

            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(centerX - roadWidth / 2, 0);
            ctx.lineTo(centerX - roadWidth / 2, canvas.height);
            ctx.moveTo(centerX + roadWidth / 2, 0);
            ctx.lineTo(centerX + roadWidth / 2, canvas.height);
            ctx.stroke();

            ctx.setLineDash([30, 30]);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.lineDashOffset = -dashOffset;
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawCar() {
            const x = carBaseX + carOffsetX;

            if (carBlinkActive) {
                const currentTime = Date.now();
                const elapsedTime = currentTime - carBlinkStartTime;

                if (elapsedTime > CAR_BLINK_DURATION) {
                    carBlinkActive = false;
                } else {
                    if (Math.floor(elapsedTime / CAR_BLINK_INTERVAL) % 2 === 0) {
                        if (carImageLoaded) {
                            ctx.drawImage(carImage, x, carY, carWidth, carHeight);
                        } else {
                            ctx.fillStyle = 'red';
                            ctx.fillRect(x, carY, carWidth, carHeight);
                        }
                    }
                    return;
                }
            }

            if (carImageLoaded) {
                ctx.drawImage(carImage, x, carY, carWidth, carHeight);
            } else {
                ctx.fillStyle = 'red';
                ctx.fillRect(x, carY, carWidth, carHeight);
            }
        }

        function updateHUDDisplay() {
            hudScore.textContent = score;

            const kmPerHourBase = 100;
            const actualSpeed = Math.round(gameSpeedMultiplier * kmPerHourBase);
            hudSpeed.textContent = `${actualSpeed} km/h`;

            const maxBarSpeed = getSpeedForScore(20000) * kmPerHourBase;
            const speedPercentage = Math.min(100, (actualSpeed / maxBarSpeed) * 100);
            speedBarFill.style.width = `${speedPercentage}%`;
            let speedBarColor = 'lightgreen';
            if (actualSpeed >= kmPerHourBase * 3.0) speedBarColor = 'red';
            else if (actualSpeed >= kmPerHourBase * 2.0) speedBarColor = 'orange';
            else if (actualSpeed >= kmPerHourBase * 1.5) speedBarColor = 'yellow';
            speedBarFill.style.backgroundColor = speedBarColor;

            hudHealthValue.textContent = `${health}%`;
            const healthPercentage = (health / 100) * 100;
            healthBarFill.style.width = `${healthPercentage}%`;
            let healthBarColor = 'limegreen';
            if (health <= 25) healthBarColor = 'red';
            else if (health <= 50) healthBarColor = 'orange';
            healthBarFill.style.backgroundColor = healthBarColor;
        }

        function updateCar(deltaTime) {
            // No direct update from keys here, as car movement is now click/tap-driven on canvas
            // The car movement based on keys (ArrowLeft/Right, A/D) is handled by the keydown/keyup events.
            // If you want to entirely replace keyboard controls with touch/click, you would remove those listeners.
            // For now, I'll keep them as an alternative or for desktop play.
            
            const movementAmount = (baseCarMoveSpeed / 1000) * deltaTime;

            if (keys.left) carOffsetX = Math.max(0, carOffsetX - movementAmount);
            if (keys.right) carOffsetX = Math.min(maxOffset, carOffsetX + movementAmount);
        }

        function resetGame() {
            score = 0;
            health = 100;
            gameOver = false;
            lampposts = [];
            gameSpeedMultiplier = getSpeedForScore(0);
            lastLamppostY = -200;
            carOffsetX = 0;
            dashOffset = 0;
            healthDrop = null;
            healthDrop25PercentGiven = false;

            blindEffectActive = false;
            blindEffectStartTime = 0;

            carBlinkActive = false;
            carBlinkStartTime = 0;

            crashSound.pause();
            crashSound.currentTime = 0;
            gameOverSound.pause();
            gameOverSound.currentTime = 0;
            collectSound.pause();
            collectSound.currentTime = 0;

            nameOverlay.style.display = 'none';
            updateButtonStates();
            updateHUDDisplay();
        }

        // Logic for Canvas Tap/Click Movement
        let tapTargetX = null; // Stores the target X position for the car to move towards

        function handleCanvasClick(e) {
            if (gameOver || paused || countdownActive) return;
            e.preventDefault(); // Prevent default browser actions like text selection
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left; // X coordinate relative to canvas

            // Calculate current car center
            const currentCarXCenter = carBaseX + carOffsetX + (carWidth / 2);

            // Determine target for car based on click location
            // If click is on the left half of the road (relative to car center or road center)
            if (clickX < currentCarXCenter) {
                tapTargetX = Math.max(0, clickX - (carWidth / 2) - carBaseX); // Move car left
            } else {
                tapTargetX = Math.min(maxOffset, clickX - (carWidth / 2) - carBaseX); // Move car right
            }
        }

        function handleCanvasTouch(e) {
            if (gameOver || paused || countdownActive) return;
            e.preventDefault(); // Prevent default browser actions (like scrolling/zooming)
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left; // X coordinate relative to canvas

            // Calculate current car center
            const currentCarXCenter = carBaseX + carOffsetX + (carWidth / 2);

            // Determine target for car based on touch location
            // If touch is on the left half of the road (relative to car center or road center)
            if (touchX < currentCarXCenter) {
                tapTargetX = Math.max(0, touchX - (carWidth / 2) - carBaseX); // Move car left
            } else {
                tapTargetX = Math.min(maxOffset, touchX - (carWidth / 2) - carBaseX); // Move car right
            }
        }

        // Countdown Logic
        function drawCountdown(number) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; // Semi-transparent background for countdown
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.font = 'bold 100px "Press Start 2P", cursive';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(number, canvas.width / 2, canvas.height / 2);
        }

        function countdownAnimation(timestamp) {
            // Initialize countdownStartTime on the very first frame of countdown
            if (countdownStartTime === 0) {
                 countdownStartTime = timestamp;
            }
            
            const elapsed = timestamp - countdownStartTime;
            const remainingTime = 3000 - elapsed; // 3000 ms = 3 seconds

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawRoad(); // Draw background elements
            drawCar();
            updateHUDDisplay();

            if (remainingTime > 2000) {
                drawCountdown(3);
            } else if (remainingTime > 1000) {
                drawCountdown(2);
            } else if (remainingTime > 0) {
                drawCountdown(1);
            } else {
                // Countdown finished
                countdownActive = false;
                paused = false;
                backgroundMusic.play();
                updateButtonStates();
                lastTimestamp = timestamp; // Reset lastTimestamp for smooth start of game loop
                animate(timestamp); // Start the main game loop
                return;
            }
            requestAnimationFrame(countdownAnimation);
        }

        let lastTimestamp = 0; // Global

        function animate(timestamp) {
            // Initialize lastTimestamp on the very first frame or after a hard reset
            if (lastTimestamp === 0) {
                lastTimestamp = timestamp;
            }

            if (paused || gameOver || countdownActive) return;

            const MAX_DELTA_TIME = 100;
            const deltaTime = Math.min(timestamp - lastTimestamp, MAX_DELTA_TIME);
            lastTimestamp = timestamp; // Update lastTimestamp for the next frame

            // Update car position based on tapTargetX
            if (tapTargetX !== null) {
                const currentCarX = carBaseX + carOffsetX;
                const moveAmount = (baseCarMoveSpeed / 1000) * deltaTime * 1.5; // Slightly faster movement towards tap
                
                if (Math.abs(tapTargetX - currentCarX) < moveAmount) {
                    carOffsetX = tapTargetX;
                    tapTargetX = null; // Reached target, stop moving
                } else if (tapTargetX > currentCarX) {
                    carOffsetX += moveAmount;
                } else {
                    carOffsetX -= moveAmount;
                }
                carOffsetX = Math.max(0, Math.min(maxOffset, carOffsetX)); // Clamp to road boundaries
            }

            // Also allow keyboard movement if keys are pressed
            updateCar(deltaTime); // This still processes keyboard inputs if available

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawRoad();
            updateLampposts(deltaTime);
            updateHealthDrop(deltaTime);
            drawCar();

            if (blindEffectActive) {
                const currentTime = Date.now();
                const elapsedTime = currentTime - blindEffectStartTime;
                if (elapsedTime < BLIND_EFFECT_DURATION) {
                    const opacity = 0.8 * (1 - (elapsedTime / BLIND_EFFECT_DURATION));
                    ctx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                } else {
                    blindEffectActive = false;
                }
            }

            updateHUDDisplay();

            const dashSpeedFactor = 0.5;
            dashOffset = (dashOffset + (gameSpeedMultiplier * baseObstacleSpeed / 1000) * deltaTime * dashSpeedFactor) % 60;

            animationId = requestAnimationFrame(animate);
        }

        window.onload = () => {
            updateButtonStates();
            updateHUDDisplay();
        };
    </script>
</body>
</html>